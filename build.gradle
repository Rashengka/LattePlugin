import java.text.SimpleDateFormat

plugins {
    id 'java'
    id 'org.jetbrains.intellij' version '1.16.0'
}

group 'cz.hqm.latte'
version '1.0-SNAPSHOT'

// Flag to enable/disable command logging
// This should be true for local development and false for distribution builds
ext.enableCommandLogging = !project.hasProperty('disableCommandLogging')

// Control output destination (terminal, file, or both)
ext.enableTerminalOutput = !project.hasProperty('disableTerminalOutput')
ext.enableFileOutput = !project.hasProperty('disableFileOutput')

// Directory for logs
ext.logsDir = project.hasProperty('logsDir') ? project.property('logsDir') : 'log'

// Create a single timestamp for the entire build/test run
// This ensures all logs from a single run go to the same directory
ext.buildTimestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date())

// Create logs directory if it doesn't exist
def logsDirectory = file(logsDir)
if (!logsDirectory.exists()) {
    logsDirectory.mkdirs()
}

// Utility function to log command output to a file and/or terminal
ext.logToFile = { String taskName, String output ->
    if (enableCommandLogging) {
        // Use the shared buildTimestamp instead of creating a new one
        def timestamp = buildTimestamp
        
        // Log to file if enabled
        if (enableFileOutput) {
            File logFile
            if (taskName == 'test') {
                // Ensure timestamped test directory exists and write summary inside it
                def dir = file("${logsDir}/${taskName}_${timestamp}")
                if (!dir.exists()) {
                    dir.mkdirs()
                }
                logFile = new File(dir, "${taskName}_${timestamp}.log")
            } else {
                logFile = file("${logsDir}/${taskName}_${timestamp}.log")
            }
            if (!logFile.exists()) {
                // Prefer the start time captured in test.doFirst if available
                def humanTs = project.hasProperty('testStartHumanTs') && project.ext.testStartHumanTs ? project.ext.testStartHumanTs : new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())
                // For test task, we want a header only; for others, include output immediately
                if (taskName == 'test') {
                    logFile.text = "=== ${taskName} executed at ${timestamp} ===\nTest start time: ${humanTs}\n\n"
                    // Append the output buffer after the header
                    logFile.append("${output}\n")
                } else {
                    logFile.text = "=== ${taskName} executed at ${timestamp} ===\n\n${output}\n"
                }
            } else {
                // Append to preserve any lines written by test-side rules (timing/memory)
                logFile.append("${output}\n")
            }
            
            // Always print the log file location so users know where to find logs
            println "Command output logged to: ${logFile.absolutePath}"
        }
        
        // Print to terminal if enabled or if both terminal and file output are disabled
        // This ensures that terminal output is enforced when no output is allowed
        if (enableTerminalOutput && !enableFileOutput || (!enableTerminalOutput && !enableFileOutput)) {
            println "=== ${taskName} executed at ${timestamp} ==="
            println output
        }
    }
}

// Utility function to log to project log directory with timestamp in log name
// This is specifically for captureRunIdeLogs and captureBuildLogs tasks
ext.logToProjectRoot = { String taskName, String output ->
    if (enableCommandLogging) {
        // Use the shared buildTimestamp instead of creating a new one
        def timestamp = buildTimestamp
        
        // Log to file if enabled
        if (enableFileOutput) {
            // Create log directory if it doesn't exist
            def logDir = file("log")
            if (!logDir.exists()) {
                logDir.mkdirs()
            }
            
            // Add timestamp to log filename for consistency with test logs
            def logFile = file("log/${taskName}_${timestamp}.log")
            logFile.text = "=== ${taskName} executed at ${timestamp} ===\n\n${output}\n"
            
            // Always print the log file location so users know where to find logs
            println "Command output logged to: ${logFile.absolutePath}"
        }
        
        // Print to terminal if enabled or if both terminal and file output are disabled
        // This ensures that terminal output is enforced when no output is allowed
        if (enableTerminalOutput && !enableFileOutput || (!enableTerminalOutput && !enableFileOutput)) {
            println "=== ${taskName} executed at ${timestamp} ==="
            println output
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'
    // Using JUnit 4 for all tests
    testImplementation 'junit:junit:4.13.2'
    // Mockito for mocking in tests
    testImplementation 'org.mockito:mockito-core:5.3.1'
    // Enable JUnit Platform with Vintage engine so IDE directory runs discover JUnit4 tests
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'
    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.9.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.9.2'
}

// See https://github.com/JetBrains/gradle-intellij-plugin/
intellij {
    version = '2023.1.5'
    type = 'IU' // Target IDE - IntelliJ IDEA Ultimate Edition
    plugins = ['com.intellij.java']
}

// Configure runIde task to handle URL schemes
runIde {
    jvmArgs = [
            '-Xms512m',
            '-Xmx1024m',
            "-Didea.mac.url.schemes=latte",
            "-Dlatte.plugin.production=false"  // Explicitly enable development mode for logging
    ]

    systemProperties = [
            'idea.mac.url.schemes': 'latte',
            'idea.app.name': 'Latte Plugin',
            'idea.paths.selector': 'LattePlugin',
            'idea.ignore.vfs.log.version.mismatch': 'true',
            'jna.nosys': 'true',
            'ide.suppress.font.warnings': 'true',
            'idea.dont.check.keymap': 'true',
            'latte.plugin.production': 'false',  // Explicitly enable development mode for logging
            'latte.plugin.log.dir': file('log').absolutePath  // Set the log directory to the project's log directory
    ]

    // Nastavení rozložení aplikace pro macOS
    autoReloadPlugins.set(true)
    
    // Log command output
    doFirst {
        println "Starting runIde task with logging enabled: ${enableCommandLogging}"
        if (enableCommandLogging) {
            println "Logs will be written to: ${file('log').absolutePath}"
        }
    }
}

// Add a task to run before runIde that sets up logging
tasks.register('prepareRunIdeLogging') {
    doLast {
        // Nothing to do here, just a hook for the logging task
    }
}

// Add a task to run after runIde that captures logs
tasks.register('captureRunIdeLogs') {
    doLast {
        if (enableCommandLogging) {
            // Create log directory if it doesn't exist
            def logDir = file("log")
            if (!logDir.exists()) {
                logDir.mkdirs()
            }

            // Only look for log files within the project directory
            def possibleLogDirs = [
                    file("log"),
                    file("build/idea-sandbox/system/log"),
                    file("build/idea-sandbox"),
                    file("build"),
                    file("temp")
            ]
            
            // Variable to track if we found and processed a log file
            boolean logFileFound = false
            StringBuilder logContent = new StringBuilder("=== IDE Log File ===\n\n")
            
            // Check all possible directories for the log file
            for (dir in possibleLogDirs) {
                if (dir.exists() && dir.isDirectory()) {
                    def ideaLogFile = new File(dir, 'idea.log')
                    if (ideaLogFile.exists()) {
                        logContent.append("Log file found at: ${ideaLogFile.absolutePath}\n\n")
                        logContent.append(ideaLogFile.text)
                        println "Captured IDE log file: ${ideaLogFile.absolutePath}"
                        logFileFound = true
                        break
                    }
                }
            }
            
            // If no log file was found, add a message to the log content
            if (!logFileFound) {
                logContent.append("No IDE log file was found in any of the following locations:\n")
                possibleLogDirs.each { dir ->
                    logContent.append("- ${dir.absolutePath}/idea.log\n")
                }
                
                // Also list any .log files found in the possible directories
                logContent.append("\nOther log files found:\n")
                boolean otherLogsFound = false
                
                for (dir in possibleLogDirs) {
                    if (dir.exists() && dir.isDirectory()) {
                        dir.eachFileRecurse { file ->
                            if (file.name.endsWith('.log')) {
                                logContent.append("- ${file.absolutePath}\n")
                                otherLogsFound = true
                            }
                        }
                    }
                }
                
                if (!otherLogsFound) {
                    logContent.append("No other log files found.\n")
                }
            }
            
            // Always create a log file, even if no IDE log file was found
            def timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date())
            def logFile = file("log/runIde_${timestamp}.log")
            logFile.text = logContent.toString()
            println "IDE logs written to: ${logFile.absolutePath}"

            // Also capture the debug.log file from the project's temp directory
            def debugLogFile = file('temp/debug.log')
            def debugLogContent = new StringBuilder("=== Debug Log File ===\n\n")
            
            if (debugLogFile.exists()) {
                debugLogContent.append("Debug log file found at: ${debugLogFile.absolutePath}\n\n")
                debugLogContent.append(debugLogFile.text)
                println "Captured debug log file: ${debugLogFile.absolutePath}"
            } else {
                debugLogContent.append("No debug log file found at: ${debugLogFile.absolutePath}\n")
                
                // Check for debug log files in other potential locations within the project
                def potentialDebugLogLocations = [
                    file('build/idea-sandbox/system/log/debug.log'),
                    file('build/idea-sandbox/system/log'),
                    file('build'),
                    file('log')
                ]
                
                debugLogContent.append("\nChecked the following locations for debug log files:\n")
                potentialDebugLogLocations.each { location ->
                    debugLogContent.append("- ${location.absolutePath}\n")
                    
                    if (location.exists() && location.isDirectory()) {
                        location.eachFileRecurse { file ->
                            if (file.name.endsWith('.log')) {
                                debugLogContent.append("  Found log file: ${file.absolutePath}\n")
                            }
                        }
                    }
                }
            }
            
            // Always create a debug log file, even if the debug.log file isn't found
            // Reuse the timestamp variable from the IDE log file handling
            def debugLogFile2 = file("log/runIde_debug_${timestamp}.log")
            debugLogFile2.text = debugLogContent.toString()
            println "Debug logs written to: ${debugLogFile2.absolutePath}"
        }
    }
}

// Configure the runIde task to run between our logging tasks
runIde.dependsOn prepareRunIdeLogging
captureRunIdeLogs.dependsOn runIde
// Make captureRunIdeLogs the task that gets executed when runIde is called
tasks.named('runIde').configure {
    finalizedBy captureRunIdeLogs
}

patchPluginXml {
    changeNotes = """
      Initial release of the Latte plugin.<br>
      <em>Supports basic Latte syntax highlighting and code completion.</em>
    """
    sinceBuild = '231'
    untilBuild = '241.*'
}

// Task to clear test artifacts (logs and test reports) so each run starts clean
// Usage: ./gradlew clearTestArtifacts
// Note: Not wired automatically to :test to keep the step explicit per ITC guidelines
tasks.register('clearTestArtifacts') {
    description = 'Removes previous test logs and reports to ensure a clean test run'
    group = 'verification'
    doLast {
        def logs = file('log')
        if (logs.exists()) {
            // delete only timestamped test dirs: test_YYYY-MM-DD_HH-MM-SS
            fileTree(logs).matching { include 'test_*' }.visit { f ->
                if (f.file.isDirectory()) {
                    project.delete(f.file)
                } else if (f.file.name ==~ /test_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.log/) {
                    // in case a stray log file is at root
                    project.delete(f.file)
                }
            }
        }
        // remove Gradle HTML test report to avoid reading stale results
        def htmlReport = file('build/reports/tests/test')
        if (htmlReport.exists()) { project.delete(htmlReport) }
        println 'Cleared previous test artifacts from log/test_* and build/reports/tests/test'
    }
}

test {
    // Use JUnit Platform so both JUnit 5 and Vintage (JUnit 4) tests are discoverable in IDE and Gradle
    useJUnitPlatform()
    // Treat a run with zero tests as an error (as per project guidelines)
    filter {
        failOnNoMatchingTests = true
    }
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
        exceptionFormat = "full"
    }

    // --- Internal counters to produce accurate summary and detect global timeouts ---
    def startedAtMsByFqn = new LinkedHashMap<String, Long>()
    def timeoutedFqns = new LinkedHashSet<String>()
    def totalCount = 0
    def successCount = 0
    def failedCount = 0
    def skippedCount = 0
    def outputBuffer = new StringBuilder()

    // Configure memory settings for test execution
    minHeapSize = '512m'
    maxHeapSize = '1024m'

    // Set overall Gradle test task timeout (individual tests have their own limits; this is a global guard)
    // Reduced from 20 minutes to 5 minutes to fail fast on global hangs, per issue requirements.
    timeout = Duration.ofMinutes(5)

    // Run tests in isolated mode to avoid cross-test interference
    // - No parallel forks
    // - New JVM for each test class
    maxParallelForks = 1
    forkEvery = 1

    // Disable JUnit Jupiter parallel execution explicitly (Vintage tests are JUnit 4)
    systemProperty 'junit.jupiter.execution.parallel.enabled', 'false'
    systemProperty 'junit.jupiter.execution.parallel.mode.default', 'same_thread'
    systemProperty 'junit.jupiter.execution.parallel.mode.classes.default', 'same_thread'

    // Add JVM arguments for module access, logging config, and error suppression
    jvmArgs = [
            // Module access
            '--add-exports=java.desktop/sun.font=ALL-UNNAMED',
            '--add-opens=java.desktop/sun.font=ALL-UNNAMED',
            '--add-opens=java.base/java.lang=ALL-UNNAMED',

            // Logging configuration at JVM level
            '-Djava.util.logging.config.file=' + project.file('src/test/resources/test-log.properties').absolutePath,
            '-Djava.util.logging.manager=java.util.logging.LogManager',

            // Suppress specific error classes at JVM level
            '-Dcom.intellij.openapi.vfs.newvfs.persistent.VfsLog.level=OFF',
            '-Dcom.intellij.openapi.editor.impl.FontFamilyServiceImpl.level=OFF',
            '-Dcom.intellij.ui.util.StyleSheetUtil.level=OFF',
            '-Djava.util.logging.LogManager.level=SEVERE',

            // IntelliJ configuration at JVM level
            '-Didea.platform.prefix=PlatformTestCaseTest',
            '-Didea.suppress.known.test.exceptions=true',
            '-Didea.ignore.vfs.log.version.mismatch=true',
            '-Didea.headless.enable.font.checking=false',
            '-Didea.use.headless.ui=true',
            '-Didea.ui.skip.css.missing.warning=true',
            '-Didea.font.system.disable=true',
            '-Djava.awt.headless=true',

            // Suppress specific warnings
            '-Dsun.java2d.noddraw=true',
            '-Dsun.java2d.d3d=false',
            '-Dsun.java2d.opengl=false',
            '-Dswing.bufferPerWindow=false'
    ]

    systemProperties([
            // Latte Plugin Test Mode Flag
            'latte.plugin.test.mode': 'true',
            
            // Pass the build timestamp to the tests
            // This ensures all logs from a single test run use the same timestamp
            'latte.plugin.test.timestamp': buildTimestamp,
            
            // Java Logging Configuration
            'java.util.logging.manager': 'java.util.logging.LogManager',
            'java.util.logging.config.file': project.file('src/test/resources/test-log.properties').absolutePath,

            // IntelliJ Platform Configuration
            'idea.platform.prefix': 'PlatformTestCaseTest',
            'idea.no.launcher': 'true',
            'idea.suppress.known.test.exceptions': 'true',
            'idea.force.use.core.classloader': 'true',
            'idea.use.core.classloader.for': 'cz.hqm.latte.plugin',
            'idea.use.core.classloader.for.plugin.path': 'true',
            
            // Language Injection Configuration
            'idea.disable.language.injection': 'true',
            'idea.ignore.duplicated.injectors': 'true',
            'idea.injected.language.manager.disabled': 'true',
            'idea.skip.injected.language.setup': 'true',
            'idea.test.no.injected.language': 'true',
            'idea.test.light.injected.language.manager': 'true',
            'idea.test.disable.language.injection': 'true',

            // UI and Headless Configuration
            'idea.use.headless.ui': 'true',
            'idea.headless.enable.font.checking': 'false',
            'idea.use.mock.ui': 'true',
            'idea.use.minimal.fonts': 'true',
            'awt.toolkit': 'sun.awt.CToolkit',
            'java.awt.headless': 'true',
            'swing.bufferPerWindow': 'false',

            // CSS and UI Warnings Suppression
            'idea.ui.skip.css.missing.warning': 'true',
            'idea.disable.css.validation': 'true',
            'idea.ui.disable.css.loading': 'true',
            'idea.ui.css.lazy.loading': 'false',
            'idea.ui.stylesheet.cache.enabled': 'false',
            'idea.ui.component.validate.on.add': 'false',

            // VFS and File System Configuration
            'idea.use.native.fs.for.win': 'false',
            'idea.ignore.vfs.log.version.mismatch': 'true',

            // Performance and Memory Configuration
            'idea.max.intellisense.filesize': '2500',
            'idea.cycle.buffer.size': '1024',
            'idea.tests.overwrite.temp.jdk': 'true',

            // Graphics and Rendering Configuration
            'sun.java2d.noddraw': 'true',
            'sun.java2d.d3d': 'false',
            'sun.java2d.opengl': 'false',
            'sun.java2d.pmoffscreen': 'false',

            // Logging Configuration
            'logback.configurationFile': 'logback-test.xml',
            'idea.log.config.file': 'logback-test.xml',
            'idea.log.path': 'build/idea-test-logs',

            // Error Suppression - Configuration File Warnings
            'java.util.logging.config.file.missing.ok': 'true',
            'idea.ignore.missing.config.files': 'true',

            // Font System Error Suppression
            'idea.font.system.disable': 'true',
            'sun.font.useJDKFontMetrics': 'false',
            'idea.use.system.fonts': 'false'
    ])

    doFirst {
        System.clearProperty("idea.ignore.duplicated.injectors")
        System.clearProperty("idea.disable.language.injection")

        // Tests are configured to run in isolated mode (forkEvery=1, maxParallelForks=1)
        println "Test isolation: forkEvery=${forkEvery}, maxParallelForks=${maxParallelForks}"

        println "Starting test task with logging enabled: ${enableCommandLogging}"
        if (enableCommandLogging) {
            println "Logs will be written to: ${file(logsDir).absolutePath}"
        }

        // Capture and persist human-readable test start time before any tests run
        def humanStartTs = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())
        project.ext.testStartHumanTs = humanStartTs
        // Pre-create the main test log file with header so that later appends do not recreate header with 'now'
        if (enableCommandLogging && enableFileOutput) {
            def ts = buildTimestamp
            def dir = file("${logsDir}/test_${ts}")
            if (!dir.exists()) { dir.mkdirs() }
            def mainLog = new File(dir, "test_${ts}.log")
            if (!mainLog.exists()) {
                mainLog.text = "=== test executed at ${ts} ===\nTest start time: ${humanStartTs}\n\n"
                println "Initialized test log: ${mainLog.absolutePath}"
            }
        }

        println "=== JVM Arguments for tests ==="
        jvmArgs.each { arg ->
            println "  $arg"
        }
        println ""

        println "=== System Properties ==="
        systemProperties.each { key, value ->
            println "  $key = $value"
        }
        println ""

        println "=== Test Log File Check ==="
        def testLogFile = project.file('src/test/resources/test-log.properties')
        println "  test-log.properties exists: ${testLogFile.exists()}"
        println "  test-log.properties path: ${testLogFile.absolutePath}"
        println "================================"
        println ""
    }
    
    // We can't directly redirect standardOutput and standardError for test tasks
    // because they're used by the test framework, but we can capture the output
    // by adding a TestListener

    beforeTest { desc ->
        if (enableCommandLogging) {
            def fqn = "${desc.className}.${desc.name}"
            startedAtMsByFqn.put(fqn, System.currentTimeMillis())
            totalCount++
        }
    }

    afterTest { desc, result ->
        if (enableCommandLogging) {
            def fqn = "${desc.className}.${desc.name}"
            def durMs = (result.endTime - result.startTime)
            def durSec = durMs / 1000.0
            def took = String.format(java.util.Locale.US, " [took %.4fs]", durSec)

            // Decide effective result, correcting SKIPPED caused by global timeout
            def effectiveType = result.resultType
            try {
                long globalTimeoutMs = timeout?.toMillis() ?: (5L * 60L * 1000L)
                // If Gradle marks SKIPPED but duration ~= global timeout, treat as TIMEOUTED
                if (result.resultType?.name() == 'SKIPPED' && durMs >= Math.max(0L, globalTimeoutMs - 1500L)) {
                    effectiveType = 'TIMEOUTED'
                    timeoutedFqns.add(fqn)
                }
            } catch (Throwable ignored) { /* fall back to original type */ }

            // Update counters
            if ("SUCCESS".equals(String.valueOf(effectiveType))) {
                successCount++
            } else if ("FAILURE".equals(String.valueOf(effectiveType))) {
                failedCount++
            } else if ("SKIPPED".equals(String.valueOf(effectiveType))) {
                skippedCount++
            } else if ("TIMEOUTED".equals(String.valueOf(effectiveType))) {
                // custom bucket
            }
            // Remove from running set if present
            startedAtMsByFqn.remove(fqn)

            // Append per-test line, with TIMEOUTED if corrected
            outputBuffer.append("Test: ${fqn} - ${effectiveType}${took}\n")
            if (result.exception) {
                outputBuffer.append("Exception: ${result.exception}\n")
                outputBuffer.append("Stack trace: ${result.exception.stackTrace.join('\n')}\n")
            }
        }
    }
    
    afterSuite { desc, result ->
        if (enableCommandLogging && desc.parent == null) {
            // This is the root suite, so all tests are complete
            def summaryTs = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())

            // Any tests that started but never finished are timeouted (likely due to global task timeout)
            long nowMs = System.currentTimeMillis()
            startedAtMsByFqn.each { fqn, startedMs ->
                // Append a synthetic TIMEOUTED line with best-effort duration
                double durSec = Math.max(0L, nowMs - (startedMs ?: nowMs)) / 1000.0
                def took = String.format(java.util.Locale.US, " [took %.4fs]", durSec)
                outputBuffer.append("Test: ${fqn} - TIMEOUTED${took}\n")
                timeoutedFqns.add(fqn)
            }

            // Count watchdog-reported timeouts and merge distinct FQNs
            try {
                def ts = buildTimestamp
                def dir = file("${logsDir}/test_${ts}")
                def mainLog = new File(dir, "test_${ts}.log")
                if (mainLog.exists()) {
                    mainLog.eachLine { line ->
                        if (line != null && line.contains("[TEST_TIMEOUT] TIMEOUT")) {
                            // Try to extract FQN after token
                            def idx = line.indexOf('] TIMEOUT')
                            if (idx >= 0) {
                                def rest = line.substring(idx + "] TIMEOUT".length()).trim()
                                def fqn = rest.contains(" after ") ? rest.substring(0, rest.indexOf(" after ")).trim() : null
                                if (fqn) { timeoutedFqns.add(fqn) } else { /* count anyway */ }
                            } else {
                                // No parse, still count
                                timeoutedFqns.add("__unknown__" + System.nanoTime())
                            }
                        }
                    }
                }
            } catch (Throwable ignored) {
                // Ignore parsing issues; logging must never break the build
            }

            int timeouted = timeoutedFqns.size()

            // Compose summary using our counters to avoid Gradle mislabeling
            int computedTotal = totalCount
            int computedSucceeded = successCount
            int computedFailed = failedCount
            int computedSkipped = skippedCount

            outputBuffer.append("\nTest summary at ${summaryTs}: ${computedTotal} tests, " +
                    "${computedSucceeded} succeeded, " +
                    "${computedFailed} failed, " +
                    "${computedSkipped} skipped, " +
                    "${timeouted} timeouted\n")

            logToFile('test', outputBuffer.toString())
        }
    }
}

runPluginVerifier {
    ideVersions = ["2023.1.5", "2023.2", "2023.3", "2024.1"]
}

tasks.withType(JavaCompile).configureEach {
    sourceCompatibility = '17'
    targetCompatibility = '17'
    options.encoding = 'UTF-8'
}

// Add a task to run before build that sets up logging
tasks.register('prepareBuildLogging') {
    doLast {
        println "Starting build task with logging enabled: ${enableCommandLogging}"
        if (enableCommandLogging) {
            println "Logs will be written to: ${file('log').absolutePath}"
        }
    }
}

// Add a task to run after build that captures logs
tasks.register('captureBuildLogs') {
    doLast {
        if (enableCommandLogging) {
            def outputBuffer = new StringBuilder()

            // Capture information about all tasks that were executed
            gradle.taskGraph.allTasks.each { task ->
                outputBuffer.append("Task: ${task.path} - ${task.state.failure ? 'FAILED' : 'SUCCESS'}\n")
                if (task.state.failure) {
                    outputBuffer.append("Failure: ${task.state.failure}\n")
                    outputBuffer.append("Stack trace: ${task.state.failure.stackTrace.join('\n')}\n")
                }
            }

            // Log the output
            logToProjectRoot('build', outputBuffer.toString())
            println "Build logs written to: ${file('log').absolutePath}/build_[timestamp].log"
        }
    }
}

// Configure the build task to run between our logging tasks
build.dependsOn prepareBuildLogging
captureBuildLogs.dependsOn build
// Make captureBuildLogs the task that gets executed when build is called
tasks.named('build').configure {
    finalizedBy captureBuildLogs
}

// Add a task to create a distribution build with logging disabled
tasks.register('distributionBuild') {
    description = 'Creates a distribution build with logging disabled'

    doFirst {
        println "Creating distribution build with logging disabled"
        // Disable command logging for all tasks
        project.ext.enableCommandLogging = false
        println "Command logging is now disabled: ${enableCommandLogging}"
        
        // Set the production flag for the Latte plugin
        System.setProperty("latte.plugin.production", "true")
        println "Set latte.plugin.production=true for disabling validation error logging"
    }

    // Run the build task for distribution
    finalizedBy tasks.build
}

// Add a simple task to test the logging functionality
tasks.register('testLogging') {
    description = 'Tests the logging functionality'

    doFirst {
        println "Testing logging functionality with logging enabled: ${enableCommandLogging}"
        if (enableCommandLogging) {
            println "Logs will be written to: ${file(logsDir).absolutePath}"
        }
    }

    doLast {
        if (enableCommandLogging) {
            def message = """
            This is a test log file.
            It was generated by the testLogging task.
            Current time: ${new Date()}
            Gradle version: ${gradle.gradleVersion}
            Java version: ${System.getProperty('java.version')}
            Operating system: ${System.getProperty('os.name')} ${System.getProperty('os.version')}
            """

            logToFile('testLogging', message)

            // Only print the log file message if file output is enabled
            if (enableFileOutput) {
                println "Test log written to: ${file(logsDir).absolutePath}/testLogging_*.log"
            }
        } else {
            println "Logging is disabled, no log file was created"
        }
    }
}